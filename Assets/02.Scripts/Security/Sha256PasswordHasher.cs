using System;
using System.Security.Cryptography;
using System.Text;

/// <summary>
/// SHA-256 알고리즘을 사용한 비밀번호 해시 처리 클래스입니다.
/// Salt를 사용하여 레인보우 테이블 공격을 방어합니다.
/// 
/// ───────────────────────────────────────────────────────────
/// 📚 학습 포인트: 단일 책임 원칙 (SRP)
/// ───────────────────────────────────────────────────────────
/// 
/// 이 클래스는 오직 "비밀번호 암호화"라는 한 가지 책임만 가집니다.
/// - UI 처리? ❌ LoginScene이 담당
/// - 데이터 저장? ❌ PlayerPrefs 또는 별도 저장소가 담당
/// - 비밀번호 암호화? ✅ 이 클래스가 담당!
/// 
/// 비유: "요리사의 역할 분담"
/// - 이 클래스는 "소스 담당 요리사"
/// - 소스 만드는 일만 전문적으로 처리
/// - 재료 손질이나 서빙은 다른 사람이 담당
/// 
/// ───────────────────────────────────────────────────────────
/// 
/// 
/// ───────────────────────────────────────────────────────────
/// 📚 학습 포인트: SHA-256 해시 알고리즘
/// ───────────────────────────────────────────────────────────
/// 
/// SHA-256이란?
/// - Secure Hash Algorithm 256-bit의 약자
/// - 어떤 길이의 입력이든 항상 256비트(32바이트) 길이의 해시값을 생성
/// - 64자리 16진수 문자열로 표현됨
/// 
/// 특징:
/// 1. 단방향성: 해시값으로 원본을 알아낼 수 없음
///    비유: "고기를 갈아서 만든 햄버거 패티 → 원래 고기 모양으로 복원 불가"
/// 
/// 2. 결정론적: 같은 입력은 항상 같은 출력
///    "password123" → 항상 "ef92b778bafe..."
/// 
/// 3. 눈사태 효과: 입력이 조금만 바뀌어도 출력이 완전히 달라짐
///    "password123" → "ef92b778..."
///    "password124" → "완전히 다른 값..."
/// 
/// ───────────────────────────────────────────────────────────
/// </summary>
public class Sha256PasswordHasher : IPasswordHasher
{
    // ═══════════════════════════════════════════════════════════
    // 상수 정의
    // ═══════════════════════════════════════════════════════════
    
    /// <summary>
    /// Salt의 바이트 길이입니다.
    /// 16바이트 = 128비트로 충분한 보안성을 제공합니다.
    /// 
    /// 📚 왜 16바이트인가요?
    /// - NIST(미국 국립표준기술연구소) 권장 최소 길이
    /// - 2^128 = 약 340간(340 undecillion) 가지의 경우의 수
    /// - 현재 기술로는 무차별 대입 공격이 사실상 불가능
    /// </summary>
    private const int SaltSize = 16;

    /// <summary>
    /// Salt와 Hash를 구분하는 구분자입니다.
    /// 저장 형식: "Salt:Hash"
    /// 
    /// 예시: "aBcDeFgH...:xYz123AbC..."
    /// </summary>
    private const char Separator = ':';

    // ═══════════════════════════════════════════════════════════
    // 공개 메서드 (Public Methods)
    // ═══════════════════════════════════════════════════════════

    /// <summary>
    /// 비밀번호를 해시화합니다.
    /// 
    /// ───────────────────────────────────────────────────────────
    /// 📚 처리 흐름
    /// ───────────────────────────────────────────────────────────
    /// 
    /// 1. 랜덤 Salt 생성 (매번 다른 값)
    /// 2. 비밀번호 + Salt 결합
    /// 3. SHA-256으로 해시 계산
    /// 4. "Salt:Hash" 형태로 반환
    /// 
    /// 예시:
    /// 입력: "MyPassword123!"
    /// 출력: "aBcDeFgHiJkLmNoP:xYz123AbCdEfGhIjKlMnOpQrStUvWxYz..."
    ///        ↑ Salt (16바이트)  ↑ Hash (64자리 16진수)
    /// 
    /// ───────────────────────────────────────────────────────────
    /// </summary>
    public string HashPassword(string password)
    {
        // 1단계: 랜덤 Salt 생성
        // 비유: "요리에 넣는 비밀 양념" - 매번 다른 양념을 사용
        byte[] saltBytes = GenerateRandomSalt();

        // 2단계: Salt를 Base64 문자열로 변환 (저장 용이)
        // Base64: 바이너리 데이터를 텍스트로 안전하게 표현하는 인코딩 방식
        string saltString = Convert.ToBase64String(saltBytes);

        // 3단계: 비밀번호와 Salt를 결합하여 해시 생성
        string hash = ComputeHash(password, saltString);

        // 4단계: "Salt:Hash" 형태로 결합하여 반환
        // 나중에 검증할 때 Salt가 필요하므로 함께 저장
        return $"{saltString}{Separator}{hash}";
    }

    /// <summary>
    /// 입력된 비밀번호가 저장된 해시와 일치하는지 검증합니다.
    /// 
    /// ───────────────────────────────────────────────────────────
    /// 📚 처리 흐름
    /// ───────────────────────────────────────────────────────────
    /// 
    /// 1. 저장된 해시에서 Salt와 Hash 분리
    /// 2. 입력된 비밀번호 + 추출한 Salt로 새 해시 계산
    /// 3. 계산한 해시와 저장된 해시 비교
    /// 
    /// 비유: "자물쇠 열기"
    /// - 저장된 해시 = 자물쇠
    /// - Salt = 자물쇠의 특수한 구조
    /// - 입력된 비밀번호 = 열쇠
    /// - 열쇠가 자물쇠 구조에 맞아야만 열림
    /// 
    /// ───────────────────────────────────────────────────────────
    /// </summary>
    public bool VerifyPassword(string password, string storedHash)
    {
        // 예외 처리: 저장된 해시가 없거나 잘못된 형식
        if (string.IsNullOrEmpty(storedHash))
        {
            return false;
        }

        // 1단계: 저장된 해시에서 Salt와 Hash 분리
        string[] parts = storedHash.Split(Separator);
        
        // 형식 검증: 반드시 "Salt:Hash" 두 부분이어야 함
        if (parts.Length != 2)
        {
            return false;
        }

        string storedSalt = parts[0];  // Salt 부분
        string storedHashValue = parts[1];  // Hash 부분

        // 2단계: 입력된 비밀번호와 추출한 Salt로 해시 계산
        string computedHash = ComputeHash(password, storedSalt);

        // 3단계: 계산한 해시와 저장된 해시 비교
        // 타이밍 공격 방지를 위해 상수 시간 비교 사용
        return SecureCompare(computedHash, storedHashValue);
    }

    // ═══════════════════════════════════════════════════════════
    // 비공개 메서드 (Private Methods)
    // ═══════════════════════════════════════════════════════════

    /// <summary>
    /// 암호학적으로 안전한 랜덤 Salt를 생성합니다.
    /// 
    /// ───────────────────────────────────────────────────────────
    /// 📚 학습 포인트: 왜 System.Random을 사용하지 않나요?
    /// ───────────────────────────────────────────────────────────
    /// 
    /// System.Random:
    /// - 시드(Seed) 값으로부터 예측 가능한 난수 생성
    /// - 게임에서는 괜찮지만, 보안에는 부적합
    /// 
    /// RandomNumberGenerator (이 코드에서 사용):
    /// - 운영체제의 암호학적 난수 생성기 사용
    /// - 예측 불가능한 진짜 랜덤 값 생성
    /// 
    /// 비유:
    /// - System.Random = 주사위 굴리기 (규칙이 있음)
    /// - RandomNumberGenerator = 우주 방사선 측정 (진짜 무작위)
    /// 
    /// ───────────────────────────────────────────────────────────
    /// </summary>
    private byte[] GenerateRandomSalt()
    {
        byte[] salt = new byte[SaltSize];
        
        // using 문: 사용 후 자동으로 리소스 해제 (IDisposable 패턴)
        using (var rng = RandomNumberGenerator.Create())
        {
            rng.GetBytes(salt);
        }
        
        return salt;
    }

    /// <summary>
    /// 비밀번호와 Salt를 결합하여 SHA-256 해시를 계산합니다.
    /// 
    /// ───────────────────────────────────────────────────────────
    /// 📚 처리 흐름
    /// ───────────────────────────────────────────────────────────
    /// 
    /// 1. 비밀번호 + Salt 문자열 결합
    /// 2. 문자열을 바이트 배열로 변환 (UTF-8)
    /// 3. SHA-256 해시 계산
    /// 4. 해시 바이트 배열을 16진수 문자열로 변환
    /// 
    /// 예시:
    /// "password" + "abc123salt" = "passwordabc123salt"
    /// → UTF-8 바이트: [112, 97, 115, 115, ...]
    /// → SHA-256: [239, 146, 183, ...]
    /// → 16진수: "ef92b778bafe..."
    /// 
    /// ───────────────────────────────────────────────────────────
    /// </summary>
    private string ComputeHash(string password, string salt)
    {
        // 비밀번호와 Salt 결합
        string combined = password + salt;
        
        // SHA256 해시 객체 생성 및 계산
        using (var sha256 = SHA256.Create())
        {
            // 문자열 → 바이트 배열 (UTF-8 인코딩)
            byte[] inputBytes = Encoding.UTF8.GetBytes(combined);
            
            // 해시 계산
            byte[] hashBytes = sha256.ComputeHash(inputBytes);
            
            // 바이트 배열 → 16진수 문자열
            return ConvertToHexString(hashBytes);
        }
    }

    /// <summary>
    /// 바이트 배열을 16진수 문자열로 변환합니다.
    /// 
    /// ───────────────────────────────────────────────────────────
    /// 📚 학습 포인트: 16진수(Hexadecimal) 표현
    /// ───────────────────────────────────────────────────────────
    /// 
    /// 1바이트 = 0~255 = 00~FF (16진수 2자리)
    /// 32바이트 = 64자리 16진수 문자열
    /// 
    /// 예시:
    /// [239, 146, 183] → "ef92b7"
    /// 239 = 0xEF = 'e' + 'f'
    /// 146 = 0x92 = '9' + '2'
    /// 183 = 0xB7 = 'b' + '7'
    /// 
    /// ───────────────────────────────────────────────────────────
    /// </summary>
    private string ConvertToHexString(byte[] bytes)
    {
        // StringBuilder 사용: 문자열 연결 시 성능 최적화
        // 비유: 블록을 하나씩 쌓는 것보다 미리 공간을 확보하고 채우는 게 빠름
        var builder = new StringBuilder(bytes.Length * 2);
        
        foreach (byte b in bytes)
        {
            // "x2": 소문자 16진수, 2자리로 표현 (예: 15 → "0f")
            builder.Append(b.ToString("x2"));
        }
        
        return builder.ToString();
    }

    /// <summary>
    /// 두 문자열을 상수 시간에 비교합니다.
    /// 
    /// ───────────────────────────────────────────────────────────
    /// 📚 학습 포인트: 타이밍 공격(Timing Attack) 방지
    /// ───────────────────────────────────────────────────────────
    /// 
    /// 일반적인 문자열 비교:
    /// "abc" vs "xyz" → 첫 글자부터 다르면 바로 false 반환 (빠름)
    /// "abc" vs "abd" → 두 글자까지 같으면 조금 더 걸림 (느림)
    /// 
    /// 문제점:
    /// 해커가 응답 시간을 측정하면 몇 번째 글자까지 맞는지 추측 가능!
    /// 
    /// 해결책 (이 메서드):
    /// 항상 모든 글자를 비교 → 응답 시간이 항상 일정
    /// 
    /// 비유: "시험 채점"
    /// - 일반 비교: 첫 문제 틀리면 바로 0점 처리 → 몇 번 문제까지 맞았는지 유추 가능
    /// - 상수 시간 비교: 모든 문제 다 채점 후 결과 발표 → 유추 불가능
    /// 
    /// ───────────────────────────────────────────────────────────
    /// </summary>
    private bool SecureCompare(string a, string b)
    {
        // 길이가 다르면 false (하지만 비교는 끝까지 수행)
        if (a.Length != b.Length)
        {
            return false;
        }

        // XOR 연산으로 차이 누적
        // 모든 글자가 같으면 diff = 0, 하나라도 다르면 diff != 0
        int diff = 0;
        
        for (int i = 0; i < a.Length; i++)
        {
            // XOR: 같으면 0, 다르면 1
            // OR로 누적: 한 번이라도 다르면 diff != 0
            diff |= a[i] ^ b[i];
        }
        
        return diff == 0;
    }
}
